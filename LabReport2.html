Code: 
import java.io.IOException;
import java.net.URI;


`class Handler implements URLHandler {
    // The one bit of state on the server: a number that will be manipulated by
    // various requests.
    String str = "";`


    public String handleRequest(URI url) {
        if (url.getPath().equals("/")) {
            return String.format(str);
        } else if (url.getPath().contains("/add-message")) {
            String nw = url.getQuery().split("=")[1];
            str = str + "\n" + nw;
            return String.format(str);
        } else {
            return "404 Not Found!";
        }
    }
`}`


`class StringServer {
    public static void main(String[] args) throws IOException {
        if(args.length == 0){
            System.out.println("Missing port number! Try any number between 1024 to 49151");
            return;
        }


        int port = Integer.parseInt(args[0]);


        Server.start(port, new Handler());
    }
}`


--------------------------------------------------------------------------------

getPath(), equals(), contains(), getQuery(), split(), and format() are called

Arguments:
* getPath() does not take any arguments and is called on the URL object
* getQuery() does not take any arguments and is called on the URL object
* split() takes “=” as its argument and is called on the output of getQuery()
* format() does not take any arguments and is called on the string containing all the input strings
* contains() takes “/add-message” as its argument and is called on the output of getPath()

![image](https://raw.githubusercontent.com/padillam2001/cse15l-lab-reports/main/scsh1.png)
![image](https://raw.githubusercontent.com/padillam2001/cse15l-lab-reports/main/scsh2.png)

The value of the str field is changed when the /add-message path is used

Part 2:

I choose the reverseInPlace() method in ArrayExamples.java

  @Test
  public void reversetestFail() {

    int[] nums = new int[3];
    int[] numsExp = new int[3];
    nums[0] = 1;
    nums[1] = 2;
    nums[2] = 3;
    numsExp[0] = 3;
    numsExp[1] = 2;
    numsExp[2] = 1;
    ArrayExamples.reverseInPlace(nums);
assertEquals(numsExp, nums);
}

@Test
public void reversetestSuccess() {

    int[] nums = new int[1];
    int[] numsExp = new int[1];
    nums[0] = 1;
    numsExp[0] = 1;
    ArrayExamples.reverseInPlace(nums);
assertEquals(numsExp, nums);
}
}

Tests:

![image](https://raw.githubusercontent.com/padillam2001/cse15l-lab-reports/main/scsh3.png)
    
The problem is that the method is writing over the first half of the array then using that written-over half to determine what will be in the second half of the array. This can be fixed by creating a copy of the input array and using that as the reference:

Before:

` static void reverseInPlace(int[] arr) {
    for(int i = 0; i < arr.length; i += 1) {
      arr[i] = arr[arr.length - i - 1];
    }
  }`
  
  `After:
   static void reverseInPlace(int[] arr) {
    int[] copy = new int[arr.length];
    for(int i = 0; i < arr.length; i += 1) {
    copy[i] = arr[i];}
    for(int i = 0; i < arr.length; i += 1) {
      arr[i] = copy[arr.length - i - 1];
    }
  }`
  
Part 3:

I learned how to fork a repository from Github and how to use Github desktop to modify a repository. I imagine these things are pretty invaluable when working on a project, let alone with a team.

